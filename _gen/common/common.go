package common

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/Southclaws/fault"
	"github.com/Southclaws/fault/fctx"
	"github.com/Southclaws/fault/fmsg"
	"github.com/gio-eui/ivgconv"
	"golang.org/x/sync/errgroup"

	"github.com/iancoleman/strcase"
)

func varname(base string) string {
	return "Icon" + strcase.ToCamel(strings.ReplaceAll(base, "-", "_"))
}

type Collection struct {
	buf        bytes.Buffer
	ivgBuffer  bytes.Buffer
	names      []string
	sourceDir  string
	targetFile string
	pkg        string
}

func NewColl(sourceDir, targetFile string) *Collection {
	pkg := filepath.Base(filepath.Dir(targetFile))
	ret := &Collection{
		targetFile: targetFile,
		pkg:        pkg,
		sourceDir:  sourceDir,
	}
	fmt.Fprintf(&ret.buf, `// auto-generated
// Code generated by '$ go run _gen'. DO NOT EDIT.

package %s

import (
		"fyne.io/fyne/v2"
		"github.com/gosthome/icons/fynico"
)

`, ret.pkg)
	fmt.Fprintf(&ret.ivgBuffer, `// auto-generated
// Code generated by '$ go run _gen'. DO NOT EDIT.

package %s

import (
		"github.com/gosthome/icons/ivg"
)

`, ret.pkg)

	return ret
}

func (col *Collection) Bundle(ctx context.Context, base string, fn string) error {
	col.names = append(col.names, base)
	ctx = fctx.WithMeta(ctx, "base", base, "fn", fn)
	eg, ctx := errgroup.WithContext(ctx)
	eg.Go(func() error {
		return col.bundleFyne(ctx, base, fn)
	})
	eg.Go(func() error {
		return col.bundleIVG(ctx, base, fn)
	})
	return eg.Wait()
}

func (col *Collection) WriteFile(ctx context.Context) error {
	eg, ctx := errgroup.WithContext(ctx)
	eg.Go(func() error {
		return col.writeFileFyne(ctx)
	})
	eg.Go(func() error {
		return col.writeFileIVG(ctx)
	})
	return eg.Wait()
}

func fyneBundle(f io.Writer, varname, staticName string, content []byte) error {
	const format = "var %s = &fyne.StaticResource{\n\tStaticName: %q,\n\tStaticContent: []byte(\n\t\t%q),\n}\n"
	_, err := fmt.Fprintf(f, format, varname, staticName, content)
	return err
}

func (col *Collection) bundleFyne(ctx context.Context, base string, fn string) error {
	var err error
	relfn, err := filepath.Rel(col.sourceDir, fn)
	if err != nil {
		return fault.Wrap(err, fmsg.With("error to bundle fyne"), fctx.With(ctx, "base", base, "fn", fn))
	}
	content, err := os.ReadFile(fn)
	if err != nil {
		return fault.Wrap(err, fmsg.With("error to bundle fyne"), fctx.With(ctx, "base", base, "fn", fn))
	}
	if err = fyneBundle(&col.buf, varname(base), relfn, content); err != nil {
		return fault.Wrap(err, fmsg.With("error to bundle fyne"), fctx.With(ctx, "base", base, "fn", fn))
	}
	return nil
}
func (col *Collection) writeFileFyne(ctx context.Context) error {
	fmt.Fprintf(&col.buf, `
var Icons = fynico.Collections.Registered(%q, fynico.Collection{
`, col.pkg)
	for _, base := range col.names {
		fmt.Fprintf(&col.buf, "	\"%s\": %s, \n", base, varname(base))
	}
	fmt.Fprintln(&col.buf, `})`)
	var err error
	fn := filepath.Join("fynico", col.targetFile)
	if err = os.MkdirAll(filepath.Dir(fn), 0o755); err != nil {
		return fault.Wrap(err, fctx.With(ctx))
	}
	f, err := os.Create(fn)
	if err != nil {
		return fault.Wrap(err, fctx.With(ctx))
	}
	defer f.Close()
	_, err = io.Copy(f, &col.buf)
	if err != nil {
		return fault.Wrap(err, fctx.With(ctx))
	}
	ld, err := os.ReadFile(filepath.Join(col.sourceDir, "LICENSE"))
	if err != nil {
		return fault.Wrap(err, fctx.With(ctx))
	}
	err = os.WriteFile(filepath.Join(filepath.Dir(fn), "LICENSE"), ld, 0o644)
	if err != nil {
		return fault.Wrap(err, fctx.With(ctx))
	}
	return nil
}

func (col *Collection) bundleIVG(ctx context.Context, base string, fn string) error {
	relfn, err := filepath.Rel(col.sourceDir, fn)
	if err != nil {
		return fault.Wrap(err, fmsg.With("error to bundle fyne"), fctx.With(ctx, "base", base, "fn", fn))
	}
	fmt.Fprintf(&col.ivgBuffer, `
// %s
var %s = ivg.IconResource{
	IconName: %q,
	IconData: []byte{`, fn, varname(base), relfn)
	defer fmt.Fprint(&col.ivgBuffer, "},\n}\n\n")
	data, err := ivgconv.FromFile(fn, ivgconv.WithOutputSize(48))
	if err != nil {
		// fmt.Fprintf(&col.ivgBuffer, "\n\t// ivg failed: %v (%+v)\n", err, fctx.GetMeta(ctx))
		// return nil
		return fault.Wrap(err, fctx.With(ctx))
	}
	for _, b := range data {
		fmt.Fprintf(&col.ivgBuffer, "0x%02x, ", b)
	}
	return nil
}

func (col *Collection) writeFileIVG(ctx context.Context) error {
	fmt.Fprintf(&col.ivgBuffer, `
var Icons = ivg.Collections.Registered(%q, ivg.Collection{
`, col.pkg)
	for _, base := range col.names {
		fmt.Fprintf(&col.ivgBuffer, "	\"%s\": &%s,\n", base, varname(base))
	}
	fmt.Fprintln(&col.ivgBuffer, `})`)
	var err error
	fn := filepath.Join("ivg", col.targetFile)
	if err = os.MkdirAll(filepath.Dir(fn), 0o755); err != nil {
		return fault.Wrap(err, fctx.With(ctx))
	}
	f, err := os.Create(fn)
	if err != nil {
		return fault.Wrap(err, fctx.With(ctx))
	}
	defer f.Close()
	_, err = io.Copy(f, &col.ivgBuffer)
	if err != nil {
		return fault.Wrap(err, fctx.With(ctx))
	}
	ld, err := os.ReadFile(filepath.Join(col.sourceDir, "LICENSE"))
	if err != nil {
		return fault.Wrap(err, fctx.With(ctx))
	}
	err = os.WriteFile(filepath.Join(filepath.Dir(fn), "LICENSE"), ld, 0o644)
	if err != nil {
		return fault.Wrap(err, fctx.With(ctx))
	}
	return nil
}

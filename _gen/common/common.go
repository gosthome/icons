package common

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/iancoleman/strcase"
)

func varname(base string) string {
	return "Icon" + strcase.ToCamel(strings.ReplaceAll(base, "-", "_"))
}

type Collection struct {
	buf     bytes.Buffer
	names   []string
	mdi_dir string
	fn      string
	pkg     string
}

func NewColl(mdi_dir, fn string) *Collection {
	pkg := filepath.Base(filepath.Dir(fn))
	ret := &Collection{
		fn:      fn,
		pkg:     pkg,
		mdi_dir: mdi_dir,
	}
	fmt.Fprintf(&ret.buf, `// auto-generated
// Code generated by '$ go run _gen'. DO NOT EDIT.

package %s

import (
		"fyne.io/fyne/v2"
		"github.com/gosthome/icons"
)

`, ret.pkg)
	return ret
}

func (col *Collection) Bundle(base string, fn string) {
	var err error
	col.names = append(col.names, base)
	fmt.Fprintf(&col.buf, `
// %s
`, fn)
	args := []string{"bundle", "--name", varname(base), "-a", fn}
	cmd := exec.Command("fyne", args...)
	cmd.Stdout = &col.buf
	cmd.Stderr = os.Stderr
	if err = cmd.Run(); err != nil {
		panic(fmt.Errorf("error running \"fyne\", \"%s\" %w", strings.Join(args, "\", \""), err))
	}
}

func (col *Collection) WriteFile() {
	fmt.Fprintf(&col.buf, `
var Icons = icons.RegisteredCollection(%q, icons.Collection{
`, col.pkg)
	for _, base := range col.names {
		fmt.Fprintf(&col.buf, "	\"%s\": %s, \n", base, varname(base))
	}
	fmt.Fprintln(&col.buf, `})`)
	var err error
	if err = os.MkdirAll(filepath.Dir(col.fn), 0o755); err != nil {
		panic(err)
	}
	f, err := os.Create(col.fn)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	_, err = io.Copy(f, &col.buf)
	if err != nil {
		panic(err)
	}
	ld, err := os.ReadFile(filepath.Join(col.mdi_dir, "LICENSE"))
	if err != nil {
		panic(err)
	}
	err = os.WriteFile(filepath.Join(filepath.Dir(col.fn), "LICENSE"), ld, 0o644)
	if err != nil {
		panic(err)
	}
}
